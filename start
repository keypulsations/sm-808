#!/bin/bash

read -p "Tempo in BPM (default 160): " tempo
tempo=${tempo:-160}
colorStart=$((320-tempo))

read -p "Amplitude (default 0.5): " amplitude
amplitude=${amplitude:-0.5}

# read -p "Number loops (default 1): " loopCount
# loopCount=${loopCount:1}

# surpress keyboard input
stty -echo

# convert tempo to ms for sleep time b/w beats
ms=$(echo "scale=3; 60 / $tempo / 4" | bc)

# set audio paths
kicksPath=(audio/kicks/*)
snaresPath=(audio/snares/*)
hihatsPath=(audio/hihats/*)

# define beats and drumkit
declare -A beats
declare -A drumkit=(
  [kick]=${kicksPath[$RANDOM % ${#kicksPath[@]}]}
  [snare]=${snaresPath[$RANDOM % ${#snaresPath[@]}]}
  [hihat]=${hihatsPath[$RANDOM % ${#hihatsPath[@]}]}
)

# these are predefined (credit: renasboy/command-line-sequencer)
# TODO: generate binary beat sequences from MIDI output generated by
# TensorFlow/Magenta neural nets trained on specific kick/snare/hh
# tracks from Splice
kick=(
  # 10000000001000001000000000100000
  # 1000000000000000
  # 0000000000100000
  # 1010000000100000
  10100000000000001010000000000000
  # 1010000000110000
  # 0011000000100000
)

snare=(
  0000100000001000
  0000000000001000
  0000100000000000
  0000100101001001
  0000100101000010
  0100100101000010
  0100100101001010
)

hihat=(
  1111011111110111
  1111011010100111
  1111011010100011
  1111011010100010
  1111011010100000
  1010101010101010
  1010011111001010
)

random() {
  beats=(
    [kick]=${kick[$RANDOM % ${#kick[@]}]}
    [snare]=${snare[$RANDOM % ${#snare[@]}]}
    [hihat]=${hihat[$RANDOM % ${#hihat[@]}]}
  )
}

start() {
  random && loop 1
}

# dry this up #####
kickPlot() {
  kickChar=$(echo -e '\u25F3')
  kickPlot="${beats[kick]//1/$kickChar}"
  kickPlot="${kickPlot//0/' '}"
  echo " kick: ${kickPlot}"
}

hihatPlot() {
  hihatChar=$(echo -e '\u25f2')
  hihatPlot="${beats[hihat]//1/$hihatChar}"
  hihatPlot="${hihatPlot//0/' '}"
  echo "hihat: ${hihatPlot}"
}

snarePlot() {
  snareChar=$(echo -e '\u25F1')
  snarePlot="${beats[snare]//1/$snareChar}"
  snarePlot="${snarePlot//0/' '}"
  printf "snare: ${snarePlot}"
}
###################

maxSteps() {
  numKickBeats="${#beats[kick]}"
  numHihatBeats="${#beats[hihat]}"
  numSnareBeats="${#beats[snare]}"

  stepLengths=($numKickBeats $numHihatBeats $numSnareBeats)
  IFS=$'\n'
  echo "${stepLengths[*]}" | sort -nr | head -n1
}

progress() {
  beat=$1
  echo -en "\e[48;5;$((beat+colorStart))m \e[0m"
}

loop() {
  local loop=$1
  [[ $loop -eq 0 ]] && return;
  printf "\n"

  stps=$(maxSteps)
  steps="$(($stps - 1))"

  for kit in "${!beats[@]}"; do
    len="${#beats[$kit]}"
    multiplier=$(expr $(maxSteps) / $len)
    str=""

    mult="$(($multiplier - 1))"

    for multiple in `seq 0 $mult`; do
      str+="${beats[$kit]}"
    done

    beats[$kit]=$str
  done

  kickPlot
  hihatPlot
  snarePlot

  printf "\n"
  printf "       "

  # TODO: determine max length sequence from kick/hihat/snare for 15
  for beat in `seq 0 $steps`; do
    for kit in "${!beats[@]}"; do
      [[ ${beats[$kit]:$beat:1} -eq 1 ]] &&
        play -q -v $amplitude ${drumkit[$kit]} -V1 &
    done

    progress $beat
    sleep $ms
  done

  printf "\n\n"
  loop $(expr $loop - 1)
}

start

# reenable keyboard input
stty echo
